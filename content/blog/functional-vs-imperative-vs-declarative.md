Title: Functional or Imperative? Declarative!
Date: 2015-03-01
Category: Code
Lang: en

These days, many people claim that functional languages are the future of programming and will eventually provide us with a perfect tool -a <em><strong>golden language</strong></em>- to solve all our programming problems. Of course, proponents of imperative programming heartily disagree with this view and in turn claim that their paradigm is the only viable solution to all of our problems. So who's right?

Personally, I think the future of programming will be neither purely functional nor purely imperative. What I think is more likely to happen is a <em><strong>Cambrian explosion</strong></em> of programming languages and paradigms. In fact, this trend is already visible today: Each year, hundreds of new programming languages are invented and published on the Internet. Some of them are the works of individuals, others are backed by large organizations. The motivations of their creators are often very different: Some just want to create a language that is more easy to read, others want to fix perceived deficiencies of older languages, and still others want to make entirely new things possible or more easy to do.

Many people see this development with great skepticism, since they think we should stop wasting our time trying to invent yet another toy language and instead work together to finally define our golden programming language. Of course, the problem here is that everyone disagrees on what's the best paradigm to actually use, which in turn is responsible for most of the -almost religious- debates around programming languages these days.

Personally, I disagree with this view, and I think we should create as many programming languages and paradigms as possible! Also, we should make it as easy as possible for a programmer out there to create and publish his own programming language. Does this sound crazy to you? Here's my reasoning:

For me, programming is about using a computer to solve a given problem in a way that is as efficient and concise as possible. The problems that people want to solve with computers are vastly different: Sometimes we need to perform mathematical calculations, or communicate over a network, or manipulate things in the physical world, or create interactive user experiences, or even perform all of these together.

Now, to make this possible we supplyare almost all geared towards "general purpose programming". They usually provide some basic storage and container types -e.g. numbers, strings, lists, or hash maps-, and an arsenal of operators and functions to manipulate them. In addition, we provide various support libraries on top of that which make it actually possible to solve real-world problems with a given programming language, as well as to "make things happen", like drawing stuff, talking to hardware or communicating over a network. Now the problem with this general-purpose approach to programming is the following:

A domain expert in a given problem field will usually have a very good mental model of the problem he is solving. Now, if he wants to write a program to solve his problem with the help of a computer, he will almost never be able to use this mental model to express a given problem. Instead, he will first have to recast his problem in a way that matches the given paradigm of the programming language he is using.

This, in my opinion, is probably the main reason that many people that are highly skilled in their respective fields (e.g. musicians, lawyers, accountants, stock brokers, writers) consider programming hard or even impossible: The mental model imposed by the programming language is so vastly different from theirs that they just cannot make them overlap in their brain, making them unable to use the language to map their problem to a program and eventually a solution. This, in my opinion, is also why languages that are simpler to learn and use, like Python or Ruby, can only slightly alleviate this problem but never solve it.

So, how can we fix this? By giving people programming languages that correspond to their learned mental models! Now, many people will probably cry out "But we already have domain-specific-languages (DSLs) for that!", but honestly, they're not even close to a solution: Most if not all of them are strongly tied to a given programming paradigm and often provide little more than "syntactic sugar" anyway. What I think of, in contrast, are programming languages that do share little or no concepts with any general-purpose programming language. Like that, an accountant could use a programming language where the basic data structures include bank accounts and currencies, and where bank transfers are operations native to the language instead of function calls on classes. Making sure that all transactions match up against each other would then be a core responsibility of the programming language instead of the programmer.

Now, don't we already do this? Yes, and no. Today there's a range of specialized programming languages that employ different mental models for solving problems. However, creating such a language still is an incredibly difficult process, which is why each year only a handful of new programming languages get mature enough to actually use them. If we could make the process of creating new programming languages easier by at least two orders of magnitude, the number of new languages would probably increase by a large factor, giving us hundreds or thousands of new, stable programming languages every year. Most of these languages will be of little use to the "general-purpose programmer", but will serve a small group of users extremely well by providing them with a problem solving tool tailored exactly to their mental model.

To achieve this, we need to provide three things:
<ol>
    <li>Make it much easier to specify and design new programming languages. It suffices to make this easy enough for a general-purpose programmer to do, since he can then work with a domain expert to create his programming language.</li>
    <li>Make sure that new programming languages can make use of the support libraries that we have written for existing languages.</li>
    <li>Make sure that the functionality of the new programming language can be easily extended by using a general-purpose language. This is necessary since it will never be possible to fully express all ideas in the domain-specific language itself (it is not a general-purpose language after all).</li>
</ol>
Today, defining a new programming language or grammar is possible using e.g. tools like Antlr and notations like EBNF, but definitely not something that an average programmer could do easily. Also, interfacing a new programming language with existing tools and libraries can be very challenging.

Overall we're on a very good way to make these three conditions true in the near future, since many tools are built that make it easier to specify and create new languages. I'm therefore confident that we will see a large influx of new programming languages catering to a wide range of mental models, and I think that's a great thing and something to look forward to.

What about you? What kind of new programming language would you create if you'd have the tools to do so easily? Which everyday problems would it solve? Let's discuss!